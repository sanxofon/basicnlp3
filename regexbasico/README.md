
# Curso r√°pido de expresiones regulares en espa√±ol

Muchas aplicaciones y lenguajes de programaci√≥n tienen su propia implementaci√≥n de expresiones regulares (*regex*), a menudo con diferencias leves y a veces significativas con respecto a otras implementaciones. Cuando dos aplicaciones usan una implementaci√≥n diferente de expresiones regulares, decimos que usan diferentes "sabores" (*flavours*) de expresiones regulares. Tratar√© de explicar la sintaxis de los "sabores" m√°s comunes, pero dejo aqu√≠ un [CheatSheet](cheatsheet.md) para referencia r√°pida y que incluye las diferencias b√°sicas que se encontrar√°n en los distintos *sabores* de *regex* m√°s comunes.

## Patrones de texto y coincidencias

Una **expresi√≥n regular* -o *regex* para abreviar- es un patr√≥n que describe una cierta cantidad de textos que tienen ciertas caracter√≠sticas similares.

Una **coincidencia** es cuando la *expresi√≥n regular* se encontr√≥ en la cadena de b√∫squeda, la coincidencia es la porci√≥n de la *cadena* que coincide con el *patr√≥n*, es decir el "pedazo de texto" que cumple las caracter√≠sticas definidas por la *expresi√≥n regular*.

Una **cadena** es un texto sobre el cual se buscar√°n *coincidencias* con la *expresi√≥n regular*.

### Caracteres literales

La *expresi√≥n regular* m√°s b√°sica consiste en un √∫nico *caracter literal*, como **a** y la b√∫squeda de s√≥lo la primera *coincidencia* en una *cadena*. Si la *cadena* es **Lupita es una ni√±a**, la primera *coincidencia* ser√° la **a** que est√° despu√©s de la **t**. Los programas que realizar expresiones regulares nos permiten recibir el *caracter* encontrado como respuesta, **a**, y/o la posici√≥n de la coincidencia, que en este caso ser√≠a **5**.

Esta expresi√≥n regular tambi√©n puede coincidir con la segunda **a**. S√≥lo lo hace cuando se le pide al motor de expresiones regulares que comience a buscar a trav√©s de la cadena **despu√©s** de la primera coincidencia. En un editor de texto, puede hacerlo utilizando su funci√≥n "Buscar siguiente" o "Buscar hacia adelante". En un lenguaje de programaci√≥n, generalmente hay una funci√≥n separada a la que puede llamar para continuar buscando a trav√©s de la cadena despu√©s de la coincidencia anterior, que busca la √∫ltima coincidencia o bien que permite buscar *todas* las coincidencias.

**Caracteres que tienen significados especiales en las expresiones regulares:**

1. la barra invertida **\\** 
1. la referencia **^** 
1. el signo de d√≥lar **$** 
1. el punto **.** 
1. el s√≠mbolo de barra vertical **|** 
1. el signo de interrogaci√≥n **?** 
1. el asterisco __*__ 
1. el signo m√°s **+** 
1. el signo de gui√≥n o menos **-** 
1. los par√©ntesis de apertura **(** y de cierre **)** 
1. los corchetes de apertura **[** y de cierre **]** 
1. y las llaves de apertura **{** y de cierre **}** 

Estos caracteres especiales a menudo se llaman "metacaracteres". La mayor√≠a de ellos muestran errores cuando no se usan adecuadamente.

Si deseas utilizar cualquiera de estos caracteres como un literal en una expresi√≥n regular, debes *escaparlos* con una barra invertida. Si quieres hacer coincidir '**1 + 1 = 2**', la expresi√≥n regular correcta es '**1 \\+ 1 = 2**'. De lo contrario, el signo m√°s (+) tiene un significado especial.

Todos los dem√°s caracteres son considerados literales y se representan a s√≠ mismos en una *expresi√≥n regular*. De forma que si nuestro patr√≥n es **abc123/"**, el motor buscar√° exactamente eso en el texto objetivo, como cualquier buscador por palabra simple.

### Clases de caracteres o juegos de caracteres

Una *clase de caracteres* coincide solo con uno de varios caracteres u opciones. Para hacer coincidir una **a** o una **e**, podemos usar el patr√≥n **[ae]**.

> Podemos usar **p[aeiou]to** y para hacer coincidir con **p*a*to**, **p*e*to**, **p*i*to**, **p*o*to** y **p*u*to**. 

Una *clase de caracter* solo coincide con **un solo** caracter: **p[aeiou]to** no concuerda con **p*aa*to**, **p*au*to**, **p*eiu*to** o cualquier cosa similar.

**El orden de los caracteres dentro de una clase de caracter no importa.**

Puedes usar un gui√≥n **-** dentro de una *clase de caracteres* para especificar un rango de caracteres. 

> El patr√≥n **[0-9]** coincide con un solo d√≠gito entre 0 y 9. 

Puedes usar m√°s de un rango.  El patr√≥n **[0-9a-z]** coincide con un solo caracter ya sea n√∫mero del **0** al **9** o una letra de la **a** a la **z** (sin acento, di√©resis ni e√±e).

> Para incluir todos los acentos del espa√±ol y la e√±e podemos usar: **[a-z√°√©√≠√≥√∫√º√±]**

Escribir una *referencia* despu√©s del *corchete de apertura* **[^** niega la clase de caracter. El resultado es que la clase de caracteres coincide con cualquier cosa que **no** est√© en la clase de caracteres.

> Por ejemplo, el patr√≥n **c[^au]lo** coincide con cualquier palabra como **celo**, **colo**, **cblo**, **c8lo**, etc. pero **no** coincide con **calo** ni con **culo**.

### Clases de caracteres abreviados

+ **\\d** coincide con un solo caracter que es un d√≠gito
+ **\\w** coincide con un "caracter de palabra" (caracteres alfanum√©ricos sin acentos m√°s gui√≥n bajo)
+ **\\s** coincide con un caracter de espacio en blanco (incluye tabulador y saltos de l√≠nea).

Las opciones negativas de las anteriores son:

+ **\D**	coincide con un solo caracter que **no** es un d√≠gito
+ **\W**	coincide con un caracter que **no** sea "caracter de palabra"
+ **\S**	coincide con un caracter que **no** sea de espacio en blanco

Los caracteres reales que coinciden con los atajos depende del software que est√° utilizando, sobre todo con letras y signos que no sean del ingl√©s, como los acentos del espa√±ol y la e√±e. Por ejemplo, el caracter **\\w** no va a coincidir con **√°**, **√©**, **√≠**, **√≥**, **√∫**, **√º** ni **√±** en versiones que no incorporen Unicode correctamente.

Ver [CheatSheet](cheatsheet.md) para saber m√°s entre las diferencias, por ejemplo, entre Python 2 y Python 3.

### Caracteres no imprimibles

Puede usar secuencias de caracteres especiales para poner caracteres no imprimibles en su expresi√≥n regular.

1. **\\t** para hacer coincidir un caracter de tabulaci√≥n
1. **\\r** para retorno de carro
1. **\\n** para salto de l√≠nea

Los elementos no imprimibles m√°s ex√≥ticos son **\\a** (campana), **\\e** (escape), **\\f** (alimentaci√≥n de formulario) y **\\v** (pesta√±a vertical). Recuerde que los archivos de texto de *Windows* usan **\\r\\n** para terminar l√≠neas, mientras que los archivos de texto de *UNIX* y *MAC* usan solamente **\\n** .

Si su aplicaci√≥n es compatible con *Unicode* , puedes usar **\\uFFFF** o **\\x{FFFF}** para insertar un caracter *Unicode* *directamente*. Por ejemplo, **\\u1F40C** o **\\x{1F40C}** coincide con el signo de un caracolito **üêå** y **\\u1F4A9** o **\\x{1F4A9}** coincide con la famosa "*pile of poo*" üí©.

Si una aplicaci√≥n no es compatible con *Unicode*, se puede usar **\\xFF** para que coincida con un caracter espec√≠fico por su √≠ndice hexadecimal en el juego de caracteres. **\\xA9** coincide con el s√≠mbolo de **‚í∏** en el juego de caracteres *Latin-1*.

Todos los *caracteres no imprimibles* se pueden usar directamente en la *expresi√≥n regular* o como parte de una *clase de caracteres*.

### El punto (.) coincide (casi) con cualquier caracter

El punto **.** coincide con un solo caracter, excepto los caracteres de *salto de l√≠nea*. La mayor√≠a de las aplicaciones tienen un modo "punto coincide con todos" o "l√≠nea √∫nica" que hace que el punto coincida con *cualquier caracter*, incluidos los *saltos de l√≠nea*.

> El patr√≥n **gr.s** y coincide con **gris**, **gr4s** , **gr%s**, etc.

**Utilice el punto con moderaci√≥n. A menudo, una clase de caracter o clase de caracter negada es m√°s r√°pida y m√°s precisa.**

### Anclajes

Los anclajes no coinciden con ning√∫n caracter sino con una posici√≥n.

El caracter **^** en un *patr√≥n regex* coincide con el comienzo de la cadena y el signo **$** coincide con el final de la *cadena*.

La mayor√≠a de los motores *regex* tienen un modo "multil√≠nea" que hace a **^** coincidir *despu√©s* de cualquier *salto de l√≠nea*, y a **$** *antes* de cualquier *salto de l√≠nea*.

> Por ejemplo, en la cadena **bob blub** el patr√≥n **^b** solo coincide con la primera **b** de _**b**ob_ y el patr√≥n **b$** solo coincide con la √∫ltima **b** de _blu**b**_.

El caracter de anclaje **\\b** coincide en un l√≠mite de palabra.

Un l√≠mite de palabras es una posici√≥n entre un caracter que puede coincidir con **\\w** y un caracter que no puede ser igualado por **\\w** . El caracter **\\b** tambi√©n coincide al principio y/o al final de la cadena si el primer y/o √∫ltimo caracteres de la cadena son *caracteres de palabra*.

El caracter **\\B** es la negaci√≥n del anterior y  coincide en todas las posiciones donde **\\b** no puede coincidir.

### Alternancia

La alternancia es la expresi√≥n regular para las opciones de m√°s de un caracter.

> El patr√≥n **gato|perro** coincide con **gato** en *Sobre gatos y perros*. Si la expresi√≥n regular se aplica nuevamente, coincide con el **perro**.

Puede agregar tantas alternativas como desee: **gato|perro|rat√≥n|pez**.

Debe agrupar las alternativas entre par√©ntesis **(opcion1|opcion2|etc.)** para usarlas normalmente en una expresi√≥n regular m√°s compleja:

> Ejemplo, **Comida para (gato|perro)** coincidir√° con **Comida para gato** y con **Comida para perro**. 

Esto se debe a que la *alternancia* tiene la precedencia m√°s baja de todos los operadores de expresiones regulares, es decir que en el patr√≥n (sin par√©ntesis) **Comida para gato|perro** las opciones definidas son **Comida para gato** por un lado y **perro** por el otro.

### Repetici√≥n

El signo de interrogaci√≥n **?** hace que el *token* anterior en la expresi√≥n regular sea opcional.

> Por ejemplo, el patr√≥n **patos?** coincide con **pato** o **patos**. Y el patr√≥n **ob?scuridad** coincide con **obscuridad** tanto como con **oscuridad**.

El asterisco __*__ le dice al motor que intente hacer coincidir el *token* anterior *con cero o m√°s veces*. La suma **+** le dice al motor que intente hacer coincidir el token anterior *una vez o m√°s*. 

> Por ejemplo, el patr√≥n __eh*__ coincidir√° con **e**, **eh**, **ehh**, **ehhh**, etc. y el patr√≥n **go+l** encontrar√° coincidencias en **gol**, **gool**, **goool**, etc. pero no en **gl**. 

Para especificar una cantidad espec√≠fica de repeticiones se usan las llaves **{ }**.

> Usa el patr√≥n **[0-9]{3}** para hacer coincidir con cualquier n√∫mero de tres cifras entre **000** y **999**, o bien se puede usar **[0-9]{2,4}** para coincidir con cualquier n√∫mero de entre dos y cuatro cifras, entre **00** y **9999**.

### Repetici√≥n codiciosa y perezosa

Los *operadores de repetici√≥n* o *cuantificadores* son **codiciosos**. Esto quiere decir que ampl√≠an la coincidencia tanto como pueden, y solo devuelven el *match* si deben satisfacer el resto de la expresi√≥n regular o si no queda nada por agregar a la coincidencia.

> Por ejemplo, el patr√≥n **a+** coincidir√° con **aaaa** en la cadena **aaaab**.

Coloque un signo de interrogaci√≥n **?** *despu√©s del cuantificador* para que sea **perezoso**.

> Por ejemplo, el patr√≥n **a+?** coincide con **a** en la cadena **aaaab**.

### Agrupando y capturando

Coloque par√©ntesis **( )** alrededor de m√∫ltiples *tokens* para agruparlos. A continuaci√≥n, puede aplicar un *cuantificador* al grupo entero.

> Por ejemplo,  el patr√≥n **Set(Value)?** coincide con **Set** o con **SetValue**.

Los par√©ntesis crean un *grupo de captura*. El ejemplo de arriba tiene *un* grupo. Una vez encontradas las coincidencias, el grupo n√∫mero uno no contiene nada si **Set** fue encontrado, pero contiene **Value** si **SetValue** fue encontrado.

C√≥mo acceder a los contenidos del grupo depende del software o del lenguaje de programaci√≥n que est√© utilizando. Los usos m√°s comunes son **\\1** √≥ **$1** para el primer grupo, **\\2** √≥ **$2** para el segundo, etc.

El grupo cero siempre contiene la coincidencia completa de la expresi√≥n regular en la cadena.

Se puede usar la *sintaxis especial* **Set(?:Value)?** para agrupar *tokens* **sin crear un grupo de captura**. Esto es m√°s eficiente en la memoria si no planea usar los contenidos del grupo. No confunda el signo de interrogaci√≥n en la *sintaxis especial* del grupo que *no captura* **(?:** con el uso de *cuantificador* que normalmente tiene el signo de interrogaci√≥n.

### Referencias para atr√°s

Dentro de la expresi√≥n regular, puede usar la *referencia inversa* **\\1** para que coincida con el mismo texto que coincidi√≥ con el primer grupo de captura (siempre anterior en la expresi√≥n).

> Por ejemplo, el patr√≥n **([abc])=\\1** coincide con **a=a** , **b=b** y **c=c** . No coincide con nada m√°s.

Si tu expresi√≥n regular tiene m√∫ltiples grupos de captura, se numeran contando sus par√©ntesis de apertura de izquierda a derecha.

> Por ejemplo, el patr√≥n **([ab])([xy])=\\1\\2** coincide *√∫nicamente* con **ax=ax**, **ay=ay**, **bx=bx** y **by=by**.

### Grupos nombrados y Referencias

Si tu expresi√≥n regular tiene muchos grupos, hacer un seguimiento de sus n√∫meros puede ser engorroso. Puedes hacer que tus expresiones regulares sean m√°s f√°ciles de leer nombrando sus grupos. 

Por ejemplo, el patr√≥n **(?P\<migrupo>[abc])=(?P=migrupo)** es id√©ntico a **([abc])=\\1**, excepto que puede hacer referencia al grupo por su nombre.

### Propiedades Unicode

En algunos lenguajes **\\p{L}** coincide con un solo caracter que se encuentra en la categor√≠a Unicode dada. L significa letra. **\\P{L}** coincide con un solo caracter que no est√° en la categor√≠a Unicode dada. *Python* no maneja esta funcionalidad, pero puede ser interesante revisar las categor√≠as *Unicode* con un *script* como el que sigue:

	import sys
	import unicodedata
	from collections import defaultdict
	unicode_category = defaultdict(list)
	for c in map(unichr, range(sys.maxunicode + 1)):
		unicode_category[unicodedata.category(c)].append(c)

Podremos capturar todos los caracteres de una categor√≠a con:

	alphabetic = unicode_category['Ll']


### Mirar alrededor (_Lookaround_)

*Lookaround* es un tipo especial de grupo. Los *tokens* dentro del grupo se buscan normalmente, pero luego el motor de expresiones regulares hace que el grupo abandone su coincidencia y solo conserva el resultado. *Lookaround* coincide con una posici√≥n, al igual que los anclajes, no expande la coincidencia de expresiones regulares.

#### Mirar adelante (_Lookahead_)

Esta funci√≥n *echa un vistazo hacia adelante* de un *token* para comprobar si el o los siguientes caracteres cumplen alguna caracter√≠stica, pero no captura nada de eso, sol mira y marca la posici√≥n.

Lookahead positivo. Si quisi√©ramos encontrar todas las letras **m** que se encuentren antes de las letras **pa** o **pe** en la *cadena* **El campe√≥n acampar√° ma√±ana**, podemos usar el patr√≥n **m(?=pa|pe)** que s√≥lo capturar√° las **m** subrayadas:

+ El ca**m**pe√≥n aca**m**par√° ma√±ana

Lo que se ponga dentro de **(?=  )** puede ser cualquier expresi√≥n regular.

Lookahead negativo. Podemos generar el resultado opuesto al anterior con el patr√≥n **m(?!pa|pe)** que capturar√≠a las **m** subrayadas:

+ El campe√≥n acampar√° **m**a√±ana

Lo que se ponga dentro de **(?!  )** puede ser cualquier expresi√≥n regular.

#### Mirar atr√°s(_Lookbehind_)

Para mirar hacia atr√°s, use *lookbehind*. 

+ Positivo: El patr√≥n **(?<=a)b** coincide con **b** en **abc** pero no en **cba**. A esto se le llama un *lookbehind positivo*.
+ Negativo: El patr√≥n **(?<!a)b** no coincide con **abc** pero s√≠ lo hace con **cba**. A esto se le llama un *lookbehind negativo*.

Puedes usar una expresi√≥n regular hecha y derecha dentro de *lookahead* pero la mayor√≠a de las aplicaciones solo permiten expresiones de longitud fija en *lookbehind*.

## Conclusiones

Combinar inteligentemente todas estas opciones no siempre es f√°cil, pero simplemente descubrir el poder de las **expresiones regulares** nos abre todo un mundo de posibilidades en el **procesamiento del lenguaje** natural en la computadoras, con el tiempo se convierte en la √∫nica forma de **buscar** que queremos... y no hemos mencionado nada de **reemplazar**.

### Referencia r√°pida

#### [CheatSheet](https://github.com/sanxofon/basicnlp/blob/master/regexbasico/cheatsheet.md)
